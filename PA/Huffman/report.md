# Huffman 解题报告
by 郑劭轩 材91 2019011852

## 算法构思
本题属于经典的Huffman编码类型题，对给定字符串生成一个最优编码树。根据讲义以及教材的讲解内容可以容易完成。

## 算法实现
算法流程的伪代码大致如下：
```
输入字符串
预处理统计词频
将词频信息添加到初始的树（森林）结构中
建立编码树
从编码树中确定各字符的编码
计算编码长度
输出
```
### 输入与预处理
用scanf读入字符串，再遍历字符串各位，统计词频。将词频大于0的字符添加到tree中。

### 建树
树（森林）的内部为向量结构，不断从中找出weight最小的2个根节点，给其添加公共的根节点，并更新新根节点的权值。如此不断循环，直至森林中只有一棵树为止。

### 编码与长度统计
从树的根节点向下传递编码信息到叶节点处，即可得知字符对应的编码，以二进制对应的十进制int型数保存。统计编码总长度时，在树存储叶节点的区段线性查找字符对应的编码，并将编码长度累加。

### 输出
遍历树存储叶节点的区段，输出字符及二进制编码即可。

## 复杂度分析
### 时间复杂度
输入与统计词频的时间为$O(n)$级别。
建树过程中，寻找最小权根结点采用了较慢的线性查找方法，时间复杂度为$O(m)$，其中m为字符种类数。以上查找的次数与字符种类数相当，故建树一步的时间复杂度为$O(m^2)$.
编码时每个结点被遍历一次，总结点数为$2m-1$，因此时间复杂度为$O(m)$
统计长度时，平均每次线性查找编码需要花费$O(m)$时间，对n位字符串则需要$O(nm)$时间
最后的输出耗时同样应与总结点数相当，为$O(m)$级别。

综合看来，由于m规模很小，相比n几乎可以视为常数，因此总时间复杂度大致为$O(nm)$级别。

封底估算：设计算机每秒执行$10^9$次计算，$nm \le 26 \times 500000 = 13000000$, 在较大的常数范围内可以满足题目限制。

### 空间复杂度
本题中开辟n长度数组用于存储字符串；树的空间为$O(m)$级别。因此空间开销为$O(n + m)$级别。

由于m相对于n很小，总空间开支为$O(n)$级别。$n \le 500000$，因此能够满足题目限制。



## 遇到的问题及解决

- 原本在tree数组内预置了26个超字符的空间，但这也使得后续建立编码树的过程中出现了一些小麻烦。因此在最后提交的版本中，tree中只存放出现过的字符。


## 参考资料
讲义：P462 Huffman编码树
教材：P145 Huffman编码