# Kidd 解题报告
by 郑劭轩 2019011852

## 算法构思
结合提示，由于本题涉及大规模的区间修改及区间查询操作，因此需要使用线段树的数据结构。由于数据规模较大，为节省时间与空间开支，我预先读取了输入数据，根据输入生成离散化的区间（线段树的叶节点）。

## 算法实现
### 输入预处理
- 一次性读取所有的输入数据，每行的`H/Q i j`分别存放到数组`com`、`_i`、`_j`中。

- 扑克牌的数量在1到n之间，n最大可达$2^31-1$。原本输入的区间为闭区间，为方便起见，本程序中区间统一采用左开右闭的表示方法，输入区间的左端点统一向左移动一位成为开区间端点，`left`数组存放`_i - 1`的值、`right`数组拷贝`_j`数组内容。

- 分别对`left`数组和`right`数组进行排序, 排序完成后对`left`与`right`做二路归并, 同时完成去重. 二路归并+去重的结果存放在数组`b`中, 数组`b`实际上就存储了全部离散化区间端点的信息. 二路归并+去重的过程被封装到了函数`Build()`中, 函数返回值为离散化区间的数目.

- 预处理的结果将会在线段树建立的过程中被使用

### 线段树
#### 结点的构成与组织方式
```cpp
long long v = 0;//结点存储的值
int l = 0,r = 0;//左开右闭区间的左右端点
long long lazy = 0;//懒惰标记
```
为尽量减小树的深度, 同时为了表示的方便, 结点构成的树将会是一棵完全二叉树, 用数组紧凑表示法存储.

#### 树的建立
建立线段树的过程被封装在成员函数`SegmentTree::initialize()`中.

内部结点数目与叶节点数目相同或比叶节点数目少一个. 为节约空间, 由于叶节点数目固定, 令内部结点数目为叶节点数目-1. 记叶节点数目为`_n_Inteval`, 则总结点数应为`2 * _n_Inteval - 1`, 记后者为`_capacity`. 此时除叶节点外所有结点都有2个子节点, 方便了后续插入与查询接口的实现. 

建立过程中需要录入所有节点的区间信息, 从叶节点开始, 再基于叶节点生成全部的区间信息.

- 计算叶节点位置并填充叶节点
    - 记`_n_Inteval - 1`的位数为`depth`, 可以证明最低的叶节点位于树的第`depth`层(根节点为第0层).
    - 最底层的叶节点数量应为总结点数减去被填满层中的总结点数, 即
    `_capacity - ((1 << depth) - 1) = _capacity - (1 << depth) + 1`
    - 因此最底层叶结点从`(1 << depth) - 1`开始, 共有`_capacity - (1 << depth) + 1`个. 
    - 进而可以算出次底层叶节点的位置
    - 依次遍历这些叶节点, 将数组`b`中的区间信息填充进结点.

- 填充内部结点
    - 先前已经计算出内部结点共`_n_Inteval - 1`个, 因此从序号为`_n_Inteval - 2`的最后一个内部结点开始向前遍历, 根据左右子节点的区间信息动态规划式地确定自己的区间信息, 并填充.

#### 插入与查询接口的实现
插入与查询接口的实现借鉴了讲义的做法, 并结合提示在讲义的基础上实现了懒惰标记功能, 实现了$O(\log m)$级别复杂度的区间插入与区间查询. 

- 若当前区间被目标区间所包含, 插入时直接更新当前区间的值, 并令懒惰标记+1; 查询时直接读取当前区间的值并返回
- 若当前区间的左/右子区间与目标区间有交集, 则向下传递懒惰标记, 并递归地转入左/右子区间
- 最后剩下的情况就是当前区间与目标区间无交集, 不执行任何操作地返回. 查询时返回0值

## 复杂度分析
### 时间复杂度
#### 输入复杂度
$O(m)$级别
#### 预处理复杂度
预处理包括:
- 对两个m长度数组的排序(采用归并排序实现, 时间复杂度为$O(m\log m)$)
- 二路归并及去重(时间复杂度为$O(m)$)

#### 建立线段树复杂度
由于查询与插入的区间数共有m个, 因此b数组至多有2m个元素, 叶节点数目`_n_Inteval`为$O(m)$规模. 进而可以得知线段树总结点数为$O(m)$规模, 高度为$O(\log m)$规模

主要的过程包括
- 确定叶节点深度($O(\log m)$)
- 填充全部结点信息(每个结点只会被访问一次, 树的总结点数为$O(m)$规模, 因此复杂度为$O(m)$)

#### 插入接口复杂度
结合课堂所学与讲义上的注解, 可以得知, 每次插入过程中, 线段树的每一层至多有4个结点被访问, 且每个结点至多被访问一次. 每次访问的时间复杂度只有$O(1)$, 因此插入的总复杂度与线段树层数相同, 为$O(\log m)$规模.

#### 查询接口复杂度
查询与插入的逻辑类似, 因此也为$O(\log m)$规模.

#### 总结与封底估算
以上所列过程中, 预处理过程只进行一次, 复杂度为$O(m \log m)$级别; 插入/查询操作进行m次, 每次为$O(\log m)$级别, 共计为$O(m\log m)$级别. 综上所述, 程序的时间复杂度为$O(m\log m)$.

做封底估算: 假定处理器每秒执行$10^9$次操作
$$
m\log m \le 200000 \log 200000 \approx 4 \times 10^6
$$

这个数值远小于$10^9$, 使得在较大常数范围内程序仍可以满足1s的运行时间限制.

### 空间复杂度

存储输入、区间预处理、存储线段树所花费的空间均为$O(m)$级别. 具体来看, 存储输入需要$3m\times4$字节, 区间预处理最多需要$4m\times4$字节(最后一步二路归并使用了先前归并排序的辅助空间), 存储线段树的数组空间约为$24(2m-1)$字节, 综上可知常数约为76.

做封底估算, 大约需要76m字节的存储空间. 由$m \le 200000$得到所要花费的存储空间为$15200000\ \text{B} \approx 14.5 \text{MB}$, 满足题目的空间限制.

## 遇到的问题及解决
### n数据规模问题
本题中扑克牌数量的数据规模巨大, 倘若每个叶节点的区间长度均为1, 必然会导致巨大的时间空间开销. 结合提示, 我决定预先读取输入信息来确定叶节点的设置.

### 左开右闭区间的选择
区间的开闭可以有以下4种方案:
- 开区间
- 闭区间
- 左开右闭区间
- 左闭右开区间

最开始的版本计划采用闭区间的表示方式, 但在后续的实现过程中发现与预处理的适配程度不佳, 会给预处理带来一些不必要的麻烦. 
半开半闭的区间需要的端点数据最少, 在考虑输入数据的范围后, 我决定使用左开右闭区间以规避可能出现的int类型溢出问题.

### 插入接口实现中出现的问题
先前版本在实现区间插入时只更新了叶节点和"命中"区间的值, 导致查询也出现了问题. 修改后的版本在访问完子区间后自动更新当前结点的值, 解决了这一问题.

## 参考资料
讲义: P450 完全二叉树 ~ 紧凑表示 ~ 以向量实现
讲义: P626~639 Segment Tree