# Hacker 解题报告
by: 郑劭轩 材91 2019011852
## 算法构思
本题使用散列表维护密文与明文的映射关系。先计算字符范围内长度1~5的字符串明文对应的密文，并将其添加到散列表中，若发现有一个密文对应多个明文的现象就将明文置为Duplicate。读取输入的密文后在散列表中寻找对应的明文并输出，查不到则输出No。若查到明文且明文非Duplicate，则用明文首字母更新集合A，将集合A中的明文添加到散列表中。

## 算法实现
### String类
为方便调用，将用于存储明文的字符串封装成了String类，除返回字符串长度和内容的接口外还实现了作为栈使用的`push()`与`pop()`接口以及自动输出接口。

### 散列表
散列函数采用取余法，表长取9999971，是一个模4余3的素数。

散列表的词条中key为`unsigned int`类型，存储密文；value为`String`类型，存储明文。为方便调用，代码重载了方括号运算符，可以直接通过下标的方式访问密文对应的明文位置。

排解冲突采用封闭散列-开放定址的策略，使用双向平方试探，在发现key值匹配或找到空桶时停止。由于本题不涉及删除操作，因此没有实现懒惰删除也能正常运行。

### 初始化
程序需要预先在密码本散列表中加入长度为1~5的字符串的信息。由于题目禁止使用5重循环，考虑到这些字符串恰好可以组成一棵18叉树（根结点为空字符串，每个结点的18个子节点分别为自身与18个字符拼接得到的字符串），因此可以使用遍历树的方式实现这些字符串的遍历。

用crc32函数分别生成这些字符串加盐后的密文，之后将密文-明文的映射关系添加到散列表中。添加的过程中检查是否出现同个密文对应多个明文的现象，若有则将明文置为Duplicate。

### 破解密文
由于输入的密文是8位的16进制数，因此可以直接用`scanf()`函数读取到`unsigned int`型的变量中去。直接用密文作为键值，利用此前重载的方括号运算符直接访问散列表中该密文的对应位置（明文）。

- 若明文的内容为空（判定标准为`String`类的`size()`返回0），则说明密码本中没有对应的密文，直接输出No

- 若明文为Duplicate（判定标准为`String`类的`size()`返回9：由于所有其它加入密码本明文长度均不超过8，因此若明文长度为9，可以直接断定明文为Duplicate），说明该密文对应多条明文，输出Duplicate（利用`String`类的`print()`接口，以输出明文内容的方式）

- 若非以上两种情况，则该位置的内容就是密文对应的明文，直接调用`print()`接口输出明文。

### 用集合A更新密码本
#### 集合A的表示
集合A的元素为A中某一字符串的所有相同结尾的子串，因此可以只记录A中最大的字符串，即可同时记录A中的全部元素。

A中最大字符串由近8个破解成功的明文的首字符构成，最近破解的明文首字母在字符串的末尾。因此，可以使用`String`类存储A中最大的字符串，并在每次破解成功后令明文首字符入栈以更新A。`push()`接口在发现长度即将超过8时会将原A除首字符外的其它字符自动向前搬移一位以腾出空间给新加入的字符，保证了A的更新规律不变。

在这种表示方法下，集合A中的第i个字符串的地址为`A.str()+i`，长度为`A.size()-i`，这种表示方法可以方便地调用CRC32函数计算对应的密文。

#### 遍历A中元素更新密码本
根据上述的表示方法可以由`String`类存储对象`A`遍历得到所有A中的字符串的地址和长度，进而得到这些字符串明文对应的密文。将密文-明文映射添加到散列表中的过程与与初始化的过程相类似，不再赘述。

#### 剪枝
1. 考虑到长度不超过5的字符串都已经在初始化过程中被添加，因此不再将A中长度不超过5的字符串添加到密码本中。

2. 在这种更新方法下，若发现某一字符串明文及其对应密文已经被添加到密码本中，则说明A中剩余的字符串明文也已经被添加到了密码本中，可以不再遍历剩余的字符串。


## 复杂度分析
### 时间复杂度
#### 初始化遍历
每个长度不超过5的字符串都会被遍历一次，共计有$18+18^2+18^3+18^4+18^5=2000718$个字符串被遍历到，需要访问2000718次散列表，与$O(n)$级别相当。

#### 破解密文
共有n条密文输入，每次寻找明文需要访问一次散列表，共计要访问n次散列表。其余操作数同样为$O(n)$级别。

#### 添加集合A中字符串明文
集合A中每次至多3个字符串明文被新添加到散列表中，访问散列表次数共计为$O(n)$级别，常数约为3。其余操作数也为$O(n)$级别。

#### 散列表
散列表的表长为9999971，预计将会向其内部添加最多3000000+2000718个词条，预计装填因子最大为0.5左右，可以每次保证访问散列表的时间复杂度为$O(1)$量级，平均试探次数控制在2左右。

#### 总结与封底估算
结合以上分析，访问散列表的次数与其余操作数均为$O(n)$级别。因此总操作数也为$O(n)$级别。

做封底估算，假设每秒计算$10^9$次，时间限制2s内可以执行$2\times 10^9$次操作。

n最大为$10^6$级别，因此在很大的常数范围内可以使得程序满足时间限制。

### 空间复杂度

每个String对象的大小为13字节，每个Entry结构体对象的大小为17字节，因此散列表的大小大约为190 MB。其余的空间开支均较为有限，预计总的空间开支将会在200 MB左右，能够满足题目的限制条件。

## 遇到的困难及解决
### 散列表长的选择
考虑到可能需要添加约5000000个词条，因此选取了一个接近10000000的模4余3的素数9999971作为表长，以保证装填因子较小，平均试探次数较少。

### 初始化遍历
由于不允许使用5重循环，考虑到字符串之间的关系可以用树来表示，因此效仿树的遍历，用递归实现了初始化的遍历。


## 参考资料
讲义：P186 筛法
讲义：P804~808 双向平方试探