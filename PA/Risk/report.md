# Risk 解题报告

by 郑劭轩 材91 2019011852

## 算法构思

### k[i]求算：利用Queap

本题需要求的低风险、中风险天数依赖于k值的计算，首先需要找到快捷的方法求算各天的k[i]。k[i]等于i日前m[i]天内最大的x[i]值，结合提示，可以考虑维护一个Queap数据结构，存放从i-m[i]日到i-1日的x[i]，这样每次即可在$O(1)$时间内通过Queap::getMax()接口获得k[i]。同时，考虑到序列i-m[i]的非减性，可以保证Queap只会在i较大的一侧进队，且只会在i较小的一侧出队，满足使用Queap的要求。

### 根据k[i]求p、q：排序

预先对k[i]进行有序化，再用二分查找快速确定小于低风险/中风险指标的k[i]所在的位置，即可迅速得到p和q的值。


## 算法实现

### Queap数据结构的实现

结合老师的课堂讲授以及讲义内容，我实现了Queap数据结构。

### 简易Queue的实现

一般而言，Queue适合用列表实现，但列表本身的实现略为复杂。考虑到本题不涉及中间位置的动态操作，尾部只出不进，且头部同时需要发生enqueue与pop，因此我采用了向量实现，用一维数组存放数据。

规定：一维数组秩较大的一端为头部，秩较小的一端为尾部。

文件Queap.h中定义了`Queue<Type>`模板类。考虑到本题中尾部只出不进，预先分配长度为天数上限的空间，使用成员变量_begin和_end分别记录尾部和头部的位置。定义了接口如下：
```cpp
    int Queue::size()           //返回队列的长度
    bool Queue::empty()         //判断队列是否为空
    void Queue::enqueue(Type e) //在队列头部加入元素e
    Type Queue::dequeue()       //队列尾部元素删除并返回被删除内容
    Type Queue::pop()           //队列头部元素删除并返回被删除内容
    Type & Queue::roar()        //返回队列尾部元素的引用
    Type front()                //返回队列头部元素的值
```
这些接口的时间复杂度均为$O(1)$级别，具体实现见代码内容。

### Queap的实现

Queap的成员变量及接口如下：
```cpp
    struct Node//辅助队列元素压缩空间为结点
    {
        int value;     //结点对应的值
        int count;     //该结点对应的元素数目
    };
    class Queap{
        private:
            Queue<int>  q;      //存放原始数据
            Queue<Node>  pm;    //辅助队列，存放子队列的最大值，并压缩了空间
        public:
            int getMax();       //读取Queap中的最大值
            void enqueue(int);  //头部进队
            int dequeue();      //尾部出队
            int size();         //返回Queap长度（即q的长度）
    };
```
#### pm空间压缩对接口实现的影响
- 由于pm仍然保持单调性，getMax()接口只须直接读取辅助队列尾部结点对应的值，没有变化。
- pm在dequeue()时只需要将尾部结点的count项减一即可，当count = 0时整个结点出队
- enqueue(e)时，pm的头部结点将会不断与待添加的e进行比较，若pm.front.value <= e则执行pop()令头部结点出队，头部结点的count将被累计。直到pm.front.value > e或队列空时，基于e构造新结点入队，对应的元素数目为被pop()的结点对应的元素数目总和+1（e本身）。

具体实现详见代码。

### 主函数

伪代码如下所示，具体实现详见代码文件。
```
//处理输入
//从0~nday遍历x[i]:
    //Queap为空则k[i] = 0
    //若Queap长度大于m[i]，dequeue()到Queap长度<=m[i]为止
    //读取getMax()并赋给k[i]
    //x[i]入队
//k[i]排序
//查找并输出
//结束
```

### 排序与查找
排序算法采用了归并排序，查找算法采用了二分查找。

## 复杂度分析

### 时间复杂度

#### Queap各接口的时间复杂度
由于不包含循环/递归结构，Queue的各个接口显然都是$O(1)$级别的。
Queap的各个接口中也只有Queap::enqueue(int)包含循环结构，因此针对该接口进行分析。其它接口的复杂度也均为$O(1)$级别。

##### Queap::enqueue(int)复杂度均摊分析

分析代码可以发现，pm中的每一个结点至多只各经历一次进队和pop，因此均摊到每一个结点上的复杂度仅为$O(1)$量级。同时，对n个结点的enqueue()总复杂度为$O(n)$

#### 主函数遍历过程的复杂度分析

由于每一个x[i]至多都只各经历一次进队或出队，且进出队的均摊复杂度均为$O(1)$量级，因此整个遍历过程也只需要花费$O(n)$级别的时间

#### 排序与查找

归并排序的时间复杂度为O(n\log n)，每次二分查找的时间复杂度为$O(\log n)$，总共T次的查找需要花费$O(T\log n)$的时间。

综上，算法整体的时间复杂度为$O(n + n\log n + T\log n)$。考虑到T的规模与n接近，且上限小于n，整体的时间复杂度可视作$O(n\log n)$

#### 封底估算

设计算机每秒计算$10^9$次，取n的上限$n = 10^6$，得$n\log n \approx 2 \times10^7$，在较大的常数范围内可以满足0.5 sec的时间限制。

### 空间复杂度

空间复杂度为$O(n)$级别，开辟的主要大空间包括：
- 用于存放输入的一维数组x、m、p、q，x、m的长度为$O(n)$量级，p、q的长度为$O(T)$量级
- 存放计算结果k[i]的一维数组，长度为$O(n)$量级
- 归并排序辅助空间b，$O(n)$量级
- Queap空间，其中包含2个同样为$O(n)$长度的Queue，因此也为$O(n)$量级。

#### 封底估算：
以上空间总大小为
$$
(6n+2T) \times 4 \text{B} < 24\text{MB}
$$
满足题目的限制。


## 遇到的问题及解决

### Queue以及Queap的实现
一般来说，队列基于列表实现最为方便。但列表的链表实现在动态内存分配上会花费大量时间，双栈当队可能会在实现pop时出现问题，游标实现则十分繁琐，前期在用游标实现队列的过程中花费了大量精力。经过思考，我发现本题只需要在处理队列首尾的变化，同时进队、出队的次数均有限，且不会超过队列的最大容量。因此，我采用了基于向量的实现方法。

## 参考资料

讲义：Queap, P365~366