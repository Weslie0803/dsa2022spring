# Not_Found 解题报告
by 郑劭轩 材91 2019011852

## 算法构思

本题对空间使用的限制十分严格. 结合提示, 由于输入01串A的长度至多为$2^{24}$, 其长度为24的子串数目必然少于$2^{24}$, 而长度为24的01串则有$2^{24}$种. 因此, B的长度不可能超过24, 可以利用这一点筛选出目标01串B.

结合提示, 我利用Bitmap记录不同长度所有出现过的子串. 用长度上限为24的滑动窗口读取A. A读取完成后从Bitmap未填满且长度最短的子串的Bitmap中找到字典序最小的未出现串, 即为B

## 算法实现
### Bitmap实现
Bitmap的实现借鉴了讲义与示例代码中的实现方法, 并根据本题情况对部分接口做了一些调整. 新增了成员变量empty记录Bitmap中未被访问到的位置的数目, 用于判断Bitmap是否被填满.

#### Bitmap初始化
初始化封装在`init()`接口中, 操作与讲义及示例代码中基本相同, 存储空间初始化为0. 另外, 成员变量`empty`在初始化时被置为Bitmap的容量.

#### 添加记录
这一过程封装在`set()`接口中. 除基本功能(将目标位置置为1)以外, 若目标位置原本为0, 则令empty值递减以更新Bitmap的填充情况. 由于程序中调用到该接口时已经预先确保了目标位置为0, 因此接口内部不再对目标位置的值做判断.

#### 检查目标位置状态
这一过程封装在`test()`接口中, 实现方法与讲义和示例代码相同.

#### 判断是否填满
封装在`full()`接口中, 根据empty的值判断, empty为0时返回true, 否则返回false.

#### 找到最短非子串
封装在`find()`接口中. 为提高效率, 先逐字节判断是否填满, 遇到未填满的字节后再逐位判断, 直至找到第一个为0的位.

### 输入处理
由于空间限制, 程序采用了滑动窗口的读取方法. 用`int`类型存储窗口内的数据, 读取时使用`getchar()`逐字符读取, 并通过移位操作存储进`int`型变量`buffer`的低位. 限制`buffer`的位数不超过24, 若超过则将最高位抹除.

### 更新Bitmap

每个长度为n的串都能自然生成2个长为n-1的子串, 通过抹去最高位或抹去最低位的方式. `buffer`也可以生成2个这样的子串. `buffer`中每读入一个字符时, 依次将`buffer`和`buffer`生成的子串添加到对应长度的Bitmap中. 由于`buffer`抹去最低位的子串就是`buffer`读入字符前的状态, 必然已经在上一次读入字符时添加到Bitmap中, 因此只考虑`buffer`抹去最高位生成的子串. 按照此法可以获得A的以当前读入位为最低位的全部长度不超过24的子串, 将这些子串添加到对应长度的Bitmap中, 如此循环下去即可确保A的所有长度不超过24的子串被遍历到. 

每次添加子串后判断当前长度子串的Bitmap是否已经填满, 并更新Bitmap被填满的最长子串的长度信息`lb`. `lb`为当前最短非子串长度的Bitmap数组单元的下标值，当前最短非子串长度为`lb+1`. 

以上过程中可能有大量的重复的子串被重复添加到Bitmap中, 导致时间开销巨大, 因此需要剪枝处理. 剪枝主要包括2方面: 
1. 只考虑长度不低于`lb`的子串, 长度低于`lb`的子串必然已经被遍历过了.
2. 在遍历`buffer`及其子串的过程中要求从长到短遍历. 如此的遍历顺序可以使得: 若发现一个串已经在Bitmap中有记录, 则它的两个最大真子串(抹去最高位的子串和抹去最低位的子串)必然也已经在Bitmap中有记录, 进而推出该串的所有子串必然都已经被记录. 因此, 若发现某串已经在Bitmap中被记录, 则不再遍历它的子串, 直接跳出到下一次读入字符.

### 确定B串
在A串处理完毕后, Bitmap对象`bm[lb]`就存储了最短非子串的信息, 目标的最短非子串B即为`bm[lb]`中字典序最小的串. 利用先前实现的`find()`接口可以直接获得B串对应的`int`数值, 并利用实现的`printb()`函数输出为01串.

## 复杂度分析
### 时间复杂度
记A的长度为$n$, $n\le 2^{24}$
#### Bitmap初始化
$2^{25}$次操作, $O(n)$级别
#### 遍历
Bitmap`set()` `test()`与`full()`接口的时间复杂度均为$O(1)$规模.

针对每一个被考察的子串分析: 每个被考察的子串只会有2种结果
1. 未在Bitmap中记录过. Bitmap可以记录的串总数为
$$
\sum_{i = 1}^{24}2^i \le 2^{25}
$$
因此这种情况最多出现$2^{25}$次.
2. 已经在Bitmap中记录过. 可以得知每个`buffer`至多出现一次这种结果. `buffer`总数为n, 因此这种情况至多出现n次.

$2^{25}$与n的上限规模相当. 综上所述, 遍历的时间复杂度为$O(n)$

#### 确定目标串
最坏情况下为$O(n)$级别.

#### 输出
$O(\log n)$级别

#### 总结及封底估算
综上所述, 程序的时间复杂度为$O(n)$. 

做封底估算, 假定每秒执行$10^9$次操作. $O(n)\le 2^{24} \le 2\times10^7$
因此在相当大的常数范围内可以保证程序满足题目的时间限制.

### 空间复杂度
主要的空间开支在Bitmap数组上. Bitmap数组共计24个, 第i个数组需要$2^{i}$位的空间, 不足一字节则取1字节, 共计为:
$$
1 + 1 + \sum_{i = 3}^{24}2^{i-3} \approx 4 \text{MB}
$$

满足题目的限制.

## 遇到的问题及解决

### 遍历时的剪枝
遍历的基本策略是遍历A的所有长度不超过24的子串并记录到Bitmap中. 尽管长度不超过24的串不超过$2^{25}$种, 但A的长度不超过24的子串仍约有$24 \times 2^{24}$个, 常数上需要优化. 为此需要做一些剪枝处理.

复杂度分析时已经提到本程序使用了2方面的剪枝: 进一步限制子串长度以及预判子串的重复情况. 早期版本的代码中只实现了限制子串长度的剪枝, 效果较为有限, 不能应对数据规模较大的情况.

早期版本在遍历`buffer`的子串时习惯性地采用了从短子串到长子串的遍历方向. 但在后来的分析与调整中, 我发现若发现长子串已经被遍历过, 则其短子串必然也已经被遍历过. 若改变遍历方向, 则可以直接跳过这些短子串, 达到剪枝的目的. 进一步的分析表明, 这一剪枝对常数有显著的优化效果, 常数大约可以降为原来的1/10左右.

## 参考资料
讲义: P178~181 位图
示例代码: Bitmap