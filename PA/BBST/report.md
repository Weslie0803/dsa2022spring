# LAB实验报告：BBST

## 实现过程
### AVL
AVL是自平衡树，左右子树的高度差不超过1。由于每次插入和删除都有可能令树失衡，因此需要在插入和删除节点后动态地调整树的结点关系，使得树恢复平衡。
恢复平衡操作方面，考虑树的3+4重构。

具体实现方面，基本仿照讲义和示例代码的实现，先实现二叉搜索树基类，再继承地实现AVL树子类，并对插入、删除的虚函数进行重写覆盖。

### Splay
伸展树中的结点被访问过后将自动被调整到根节点的位置。为避免反复出现最坏情况，伸展算法采用双层伸展。

具体实现方面，基本仿照讲义和示例代码，继承二叉搜索树基类实现Splay子类。由于访问均会对树的结构进行调整，因此插入、查找、删除接口都需要重写。


## 复杂度分析
### AVL
AVL保证树平衡性，因此查找的耗时为$O(\log n)$。每次插入和删除时需要进行重平衡操作，调整次数不超过$O(\log n)$。因此AVL树插入、查找、删除的时间复杂度均在$O(\log n)$级别，常数可能较大。而空间复杂度在$O(n)$级别

AVL树的缺陷在于重复的插入/删除过程中会花费大量经历完成重平衡操作，导致算法的常数很大。

### Splay
结合讲义中的证明，伸展树的分摊复杂度为$O(\log n)$，与AVL相当。其优势在于局部性好，对重复的插入/删除操作，分摊成本仅为常数。

但伸展树无法杜绝最坏情况的产生。

## 测例设计
针对于AVL与Splay设计针对性的测例，分别设计2种测例：
1. 重复的插入与删除
2. 偏向一侧

预计前者在Splay中表现良好，而在AVL中性能较差；后者在AVL中表现良好，Splay中性能较差。

## 性能表现及原因分析
性能表现与预测基本一致。原因方面，根据之前复杂度分析方面的讨论，重复的插入与删除会令AVL频繁调整结构，算法的常数增加；而Splay无法避免偏向一侧的最坏情况，在该情况下表现不如AVL。

## 参考资料
讲义：AVL树，伸展树部分
示例代码