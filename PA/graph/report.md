# Graphic 解题报告
by 郑劭轩 材91 2019011852

## 算法构思
可以直观地理解：将x轴与y轴上的点分别根据与原点的距离排序，要保证任意2条线段不相交，当且仅当连线方法为同次序的x轴点与y轴点连线。

证明：任取x轴点，记其次序为i，该点记为$x_i$；记与其相连的y轴点为$y_j$。要保证其它线段不与这条线段相交，其它线段的x轴点与y轴点必须在这条线段的同侧。因此次序大于i的x轴点数目应与次序大于j的y轴点数目相同，即有$i=j$。因此连线方法必须为同次序的x轴点与y轴点连线。

由于线段两两不相交，因此这些线段在空间上是有序的，次序即为线段端点的次序。判断线段OP与几条线段相交的问题，实质上就是查找P点位于其内侧的距离原点最近的线段。因此，此处可以采用二分查找的算法。

采用二分查找的算法需要给出P点位于线段内侧或外侧（包含重合）的判据，这可以利用几何学知识推导出。

## 算法实现
### 排序
算法的第一步，需要将存储x轴点的数组`x[n]`与y轴点的数组`y[n]`分别按照数值大小排序。本题代码中采用了归并排序算法（merge sort）作为排序算法。

### P点位置判据
由x轴点与y轴点坐标可以直接写出直线i的截距式方程：
$$
    \frac{x}{x_i} + \frac{y}{y_i} = 1
$$
若$P(Px,Py)$点位于直线i内侧，则有
$$
    \frac{Px}{x_i} + \frac{Py}{y_i} < 1
$$
外侧（包括重合）则有
$$
    \frac{Px}{x_i} + \frac{Py}{y_i} \ge 1
$$
考虑到参与运算的均为整型，除法可能会引起较大误差，因此将方程改写为乘法的形式：
$$
    \begin{cases}
        Px \times y_i + Py \times x_i < x_i y_i &\text{if }内侧\\
        Px \times y_i + Py \times x_i \ge x_i y_i &\text{if }外侧（包括重合）
    \end{cases}
$$

### 查找
查找采用二分查找算法，用判据判定P点在直线i的内侧或外侧，逐步缩小范围，直到找到P点位于其内侧的距原点最近的直线i，返回i值。若找不到则说明P点位于全部直线的外侧，返回n值。

实际实现中查找的是与OP有交点的距原点最远的直线i（i最大），即P点位于其外侧（包括重合）的距原点最远的直线i，返回i+1值。若找不到则说明P点位于全部直线的内侧，返回0。

容易看出两种查找是等效的。

### 伪代码
```
//处理输入
//对x、y数组排序
//查找
//若找到则返回序号i，没找到则返回n
//结束
```

## 复杂度分析
### 时间复杂度
本算法中主要的耗时步骤在于排序以及后续的查找。
归并排序的时间复杂度为$O(n\log n)$，因此排序部分的时间复杂度为$O(n\log n)$级别。
查找步骤中，二分查找的时间复杂度为$O(log n)$，对每一个输入的P点坐标都要进行一次查找，共需要查找m个点，因此查找部分的时间复杂度为$O(m\log n)$级别。
由于n与m的数据规模接近，因此认为算法的时间复杂度为$O(n\log n)$级别

进行封底估算：设处理器每秒进行$10^9$次运算，0.5s的运算次数为$5\times 10^8$次。$n \log n \le 200000 \log_2 200000 \approx 3.5\times10^6$，能够满足题目限制。

### 空间复杂度
主要的空间开支用于x、y数组的存储，以及归并排序所需的存储空间。空间复杂度为$O(n)$级别。

考虑主要的3个`int`型数组占用的空间，共为$4\times 200000 = 800000\text{B} \approx 780\text{KB}$，满足题目限制。

## 遇到的问题及解决
### 排序算法的选择
快速排序算法与归并排序算法都是$O(n\log n)$复杂度的算法，在第一版的实现中我采用的是快速排序算法。但考虑到快速排序算法的运行速度受样例影响较大，最差情形下的复杂度达到$O(n^2)$规模，有可能引起超时。考虑到这道题的空间压力较小，我改用了归并排序算法。

### 归并排序的空间管理
讲义中的归并排序使用了动态分配的方法来获得用于存储数组数据的内存空间。显然，动态分配内存空间的耗时较长，会显著拖慢算法运行的速度。我的优化分为以下2个阶段：
- 将动态分配内存改为静态声明一个与原数组等长的数组
这一改进避免了动态分配内存空间，提高了运行效率。但直接在函数内部创建数组会使得调用栈中帧的体积增大，栈的维护成本有一定上升；在递归调用到底部时占用的总空间为2n，其中大部分闲置，还有优化的空间。
- 因此，我在函数外部声明了长度为n的数组b用于缓存数据，同样可以满足归并排序的空间要求。占用的额外空间为n。

### 判断P点位置时的数据溢出问题
之前提到，为避免除法带来的计算误差，我将原版的截距式方程改写为了一般式（乘法形式）。但坐标的范围在$0~2^31$范围内，两个坐标值相乘会超过`int`类型的上限，导致数据溢出错误。为应对这一潜在问题，在计算判据条件前，我将参与计算的坐标数据类型改为`long long`，从而能够避免数据溢出。

## 参考资料
讲义：归并排序，P175~P177
讲义：调用栈，P276~P281