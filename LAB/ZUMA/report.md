# ZUMA

## 01.cpp
1.  错误类型：**Runtime Error**

2.  错误原因：

    没有处理好在头部发生消除的情况。若在头部发生消除，01中`play()`函数在完成消除时，被消除区间的左端点`left = 0`。为考虑连消情形，程序执行了`play(left - 1)`操作，检查`left`左侧位置是否存在连消的可能性。但此时left = 0, 左侧没有元素，`play(-1)`在访问字符串a的-1位置时发生了越界访问错误。

3.  测例：压缩文件中的 `01.in`

4.  测例构造思路：

    构造一个在头部发生消除的测例。`play()`函数完成消除时，被消除区间的左端点`left = 0`，在继续执行`play(left - 1)`时实际执行了`play(-1)`，在其中循秩访问字符串`a`的过程中访问了`a[-1]`导致了越界访问错误。


## 02.cpp
1.  错误类型：**Runtime Error**

2.  错误原因：
    
    02在检测连消前加入了对`left`大小的判断，在`left - 1 >= 0`时调用`play(left-1)`，否则调用`play(left)`。但02没有考虑`left >= a.size()`的情形。当`left = 0`且`a.size() = 0`时，即结果为空序列时，调用`play(left)`同样会发生越界错误。

3.  测例：见压缩文件中的`02.in` 

4.  测例构造思路：
    
    构造一个结果为空序列的测例，最简单的即为初始序列为AA，在0位插入A的情形。完成第一次区间消除时`play`函数中`left = 0`，继续调用`play(left)`时在函数内部访问了空字符串的`a[0]`，越过了`a.size() = 0`，发生越界访问错误。

## 03.cpp
1.  错误类型： **Time Limit Exceeded**

2.  错误原因：
    
    03使用`string`容器存储轨道上的珠子序列，动态操作（插入与删除）的开销较大（$O(n)$级别），插入次数为`m`时时间复杂度为$O(nm)$量级，在数据规模较大，插入次数较多时容易超时。

3.  测例：见压缩文件中的`03.in`

4.  测例构造思路：
    
    考虑最极端的情况，构造一个长的初始序列（长度达到数据规模的上限），之后不断在0位插入珠子，迫使每次插入都要移动整个序列，令程序超时。

## 04.cpp
1.  错误类型：**Wrong Answer**

2.  错误原因： 

    在消除珠子时对消除区间的确定上，04中，左闭右开消除区间的左边界`left`将会落在相同颜色连续珠子序列的外侧。这将会导致珠子的错误删除，造成程序结果的错误。

3.  测例：见压缩文件中的`04.in`

4.  测例构造思路：
    
    构造一个消除区间的左边有应保留的珠子的测例，如设定初始序列为ABB，在2位插入B。正常情况下结果应该为A，但由于04在执行消除操作时将消除区间左边界放在了连续颜色珠子序列的外侧，会连同A一并删除，错误输出了空序列的结果。

## 05.cpp
1.  错误类型：**Wrong Answer**

2.  错误原因：

    05使用`cin`输入初始序列。当初始序列为空时，`cin`会自动将操作次数`m`当作初始序列输入，导致输入发生混乱。这意味着05无法处理空初始序列的情形。

3.  测例：见压缩文件中的`05.in`

4.  测例构造思路：
    
    初始序列设定为空序列，`cin`将默认读取操作次数`m`，后续输入也会变得混乱，输出错误结果。

## 06.cpp
1.  错误类型：**Wrong Answer**

2.  错误原因：

    06使用分块数组进行存储，使插入和删除的平均复杂度可以达到$O(\sqrt n)$级别。但每段数组的长度有上限，06中没有实现重新分配数组分块的功能，运行中有可能会出现某个数组长度超过上限，导致数组访问越界的情况。这将使内存填充到错误的位置，导致输出结果错误。

3.  测例： 见压缩文件中的`06.in`

4.  测例构造思路：
    
    不断对同一块分块数组进行插入导致越界访问，令本不应该修改的内存区域被修改。构造的测例中，初始序列为总长为5000，周期为2的"ZY"周期序列，在输入时会被自动分为3块。不断在0位交替插入A与B，保证珠子不会被消除，第0个块将会被填满。由于内存地址连续，第0块被填满后，`memmove()`操作将会修改到第1块的内容，造成第0块与第1块的重叠。在拼合时，块1重叠部分原有的数据已经被覆盖，块0溢出的数据会被输出2次，输出错误结果。

## 07.cpp
1.  错误类型：**Wrong Answer**

2.  错误原因：

    07在计算消除区间时，区间左边界的确定方法存在问题。当发现`l.second < 0`且`--l.first  >= 0`时，07的算法只是给`l.second`加上一次`plen[l.first]`。若`plen[l.first]` = 0，在退出循环时仍然会有`l.second < 0`的情况。事实上，`plen[l.first]` = 0的情况是有可能出现的，此时在调用函数`get(l)`时就会出现越界访问的问题，坐标`l`实际指向未定义的位置。在后续判断连消的步骤中，坐标`l`无法反映上个消除区间周边的情况，将会导致连消判断出现错误，输出错误结果。

3.  测例： 见压缩文件中的`07.in`

4.  测例构造思路：
    
    构造一个中间某块被清空，且空块的下一块头部发生消除的情形。构造的测例中，初始序列前2048个字母为XXDD周期序列，接下来2048个字母为AABB周期序列，最后三个字母为CCD，分块方法将保证以上三个部分恰好被分在3个块内，分别为块0、块1、块2。在2048位交替插入各512个A和B，使得块1清空。再在2049位插入C，令块2头部发生消除。此时在计算消除区间时，区间左外边界`l`有`l.second = -1`，且由于`plen[1] = 0`，判断一次后仍有`l.second = -1`。此时l实际指向`p[0][4095]`，未访问状态下默认为0。在判断连消时，标记珠子字符的变量`ch`考虑到`l`的状态，应被置为0，且由于`l.second < 0`、`l.first = 0`，`l`只能向左移动一位，而坐标`r`指向的珠子字符不为0，设置的连消判断条件（`dis > 3`）无法达成，无法判断出连消，输出错误结果。

## 08.cpp
1.  错误类型: **Wrong Answer**

2.  错误原因：

    08未考虑到连消情形，`play()`函数在判断到一个具有3个连续元素的消除区间并消除后就结束了。

3.  测例： 见压缩文件中的`08.in`

4.  测例构造思路：
    
    只需要构造一个简单的连消情形，如初始序列为AABBA，在4位插入B，08由于没有考虑连消将会输出AAA的错误结果。

## 09.cpp
1.  错误类型: **Runtime Error**

2.  错误原因：

    09未考虑消除区间的左右边界位于分块数组同一行的情形，错误地判断了左边界所在行的长度变化，认为该行中左边界后的点都将被消除。这进而导致了在后续调用`memmove()`函数时被移动内存长度的计算出现错误，移动内存长度传入了负数值，导致内存操作错误而退出。

3.  测例： 见压缩文件中的`09.in`

4.  测例构造思路：

    构造一个消除区间的左右边界位于同一个分块，且消除区间右侧仍有珠子的情形，最简单的即为只有一个分块的情形。构造的测例中，初始序列置为AABBC，在3位插入B后，正常结果应当为AAC。而09默认会将该块中消除区间左边界之后的点都消除，因此C也会被消除，返回错误结果AA。



## 10.cpp
1.  错误类型: **Wrong Answer**

2.  错误原因：

    10在执行消除操作时，对左边界`l`与右边界`r`不在同一行的情形，10先执行了`l`所在行的消除操作，再执行了`r`所在行的消除操作，最后执行`l`行与`r`行之间可能存在的行的消除操作。但10在执行消除`l`行与`r`行之间行的操作时连同删除了`l`行，这将导致删除了过多元素，造成输出错误。

3.  测例： 见压缩文件中的`10.in`

4.  测例构造思路：
    
    构造一个消除区间左右边界不在同一个分块中的情形。构造的测例中，初始序列前2048个字符为ZZYY周期序列，剩余6个字符为AABBCC。在2047位插入Y发生消除，左边界`l`应当位于`p[0][2045]`，右边界应当位于`p[1][0]`，执行删除操作时块0被删除。块0的误删除没有被计入到`alen`的变化中，导致`a`的边界没有改变。重新组装时由于块0被删除，块1填充到了`a`的头部，初始`a`的剩余部分未被覆盖，最后会输出由块1及未被覆盖的初始序列组成的错误结果。